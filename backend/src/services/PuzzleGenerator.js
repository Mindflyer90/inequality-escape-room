import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { randomInt, randomUUID } from 'crypto';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

class PuzzleGenerator {
  constructor(claudeService = null) {
    this.config = this.loadConfig();
    this.claudeService = claudeService;
  }

  loadConfig() {
    const configPath = join(__dirname, '../../config/puzzle-config.json');
    const configData = readFileSync(configPath, 'utf-8');
    return JSON.parse(configData);
  }

  async generate(difficulty = 'easy') {
    if (!['easy', 'medium', 'hard'].includes(difficulty)) {
      throw new Error('Invalid difficulty level');
    }

    // Try to generate puzzle using Claude first
    if (this.claudeService && this.claudeService.isConfigured()) {
      try {
        console.log(`Generating puzzle with Claude (difficulty: ${difficulty})...`);
        const claudePuzzle = await this.claudeService.generatePuzzle(difficulty);
        
        if (claudePuzzle && claudePuzzle.inequality && claudePuzzle.solution) {
          console.log('✓ Puzzle generated by Claude');
          return {
            id: randomUUID(),
            inequality: claudePuzzle.inequality,
            solution: claudePuzzle.solution,
            steps: claudePuzzle.steps || [],
            difficulty,
            mode: 'freeform',
            options: null,
            createdAt: new Date().toISOString(),
            generatedBy: 'claude'
          };
        }
      } catch (error) {
        console.warn('Claude puzzle generation failed, falling back to algorithmic generation:', error.message);
      }
    }

    // Fallback to algorithmic generation
    console.log('Using algorithmic puzzle generation...');
    const { minCoeff, maxCoeff } = this.config.difficulty[difficulty];
    
    // Generate coefficients (excluding zero)
    let a = this.generateCoefficient(minCoeff, maxCoeff);
    let b = this.generateCoefficient(minCoeff, maxCoeff);
    let c = this.generateCoefficient(minCoeff, maxCoeff);
    
    // Select random operator
    const operator = this.config.operators[randomInt(0, this.config.operators.length)];
    
    // Construct inequality: ax + b [operator] c
    const inequality = this.formatInequality(a, b, operator, c);
    
    // Calculate solution
    const solution = this.calculateSolution(a, b, operator, c);
    
    return {
      id: randomUUID(),
      inequality,
      solution,
      difficulty,
      mode: 'freeform',
      options: null,
      createdAt: new Date().toISOString(),
      generatedBy: 'algorithmic'
    };
  }

  generateCoefficient(min, max) {
    let coeff;
    do {
      coeff = randomInt(min, max + 1);
    } while (coeff === 0);
    return coeff;
  }

  formatInequality(a, b, operator, c) {
    // Format: ax + b [operator] c
    let inequality = '';
    
    // Handle coefficient 'a'
    if (a === 1) {
      inequality = 'x';
    } else if (a === -1) {
      inequality = '-x';
    } else {
      inequality = `${a}x`;
    }
    
    // Handle constant 'b'
    if (b > 0) {
      inequality += ` + ${b}`;
    } else if (b < 0) {
      inequality += ` - ${Math.abs(b)}`;
    }
    
    // Add operator and right side
    inequality += ` ${operator} ${c}`;
    
    return inequality;
  }

  calculateSolution(a, b, operator, c) {
    // Solve: ax + b [operator] c
    // Step 1: ax [operator] c - b
    // Step 2: x [operator] (c - b) / a
    
    const rightSide = c - b;
    const solutionValue = rightSide / a;
    
    // If we divide by negative coefficient, flip the operator
    let finalOperator = operator;
    if (a < 0) {
      finalOperator = this.flipOperator(operator);
    }
    
    // Format solution
    return this.formatSolution(finalOperator, solutionValue);
  }

  flipOperator(operator) {
    const operatorMap = {
      '>': '<',
      '<': '>',
      '≥': '≤',
      '≤': '≥'
    };
    return operatorMap[operator];
  }

  formatSolution(operator, value) {
    // Format as: x [operator] value
    // Handle fractions and decimals
    if (Number.isInteger(value)) {
      return `x ${operator} ${value}`;
    } else {
      // Keep as decimal for simplicity
      return `x ${operator} ${value.toFixed(2)}`;
    }
  }

  generateMultipleChoice(puzzle) {
    const correctAnswer = puzzle.solution;
    const distractors = this.generateDistractors(correctAnswer);
    
    // Combine correct answer with distractors
    const allOptions = [correctAnswer, ...distractors];
    
    // Randomize positions
    const shuffledOptions = this.shuffleArray(allOptions);
    
    return {
      ...puzzle,
      mode: 'multiple-choice',
      options: shuffledOptions
    };
  }

  generateDistractors(correctSolution) {
    // Parse the correct solution to extract operator and value
    const match = correctSolution.match(/x\s*([><=≥≤]+)\s*([-\d.]+)/);
    if (!match) {
      throw new Error('Invalid solution format');
    }
    
    const operator = match[1];
    const value = parseFloat(match[2]);
    
    const distractors = [];
    
    // Distractor 1: Wrong operator, same value
    const flippedOperator = this.flipOperator(operator);
    distractors.push(`x ${flippedOperator} ${Number.isInteger(value) ? value : value.toFixed(2)}`);
    
    // Distractor 2: Same operator, value off by small amount
    const offset1 = value + (Math.random() > 0.5 ? 1 : -1) * (Math.floor(Math.random() * 3) + 1);
    distractors.push(`x ${operator} ${Number.isInteger(offset1) ? offset1 : offset1.toFixed(2)}`);
    
    // Distractor 3: Wrong operator, value off by different amount
    const offset2 = value + (Math.random() > 0.5 ? 2 : -2);
    distractors.push(`x ${flippedOperator} ${Number.isInteger(offset2) ? offset2 : offset2.toFixed(2)}`);
    
    return distractors;
  }

  shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = randomInt(0, i + 1);
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
}

export default PuzzleGenerator;
